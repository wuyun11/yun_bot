# Agent 会话记忆存储说明

本文说明 **LangChain `create_agent` 的对话存储机制**，以及它与 P4_RAG 里「Runnable + BaseChatMessageHistory」方式的区别，便于在 yun_bot 的 agent_app 中正确做多轮会话记忆。

---

## 1. 两套不同的“对话存储”机制

LangChain 里和“多轮对话、会话记忆”相关的常见有两种，**不要混用**：

| 机制 | 适用对象 | 谁在“调”存储 | 典型用法 |
|------|----------|----------------|----------|
| **RunnableWithMessageHistory + BaseChatMessageHistory** | 普通 **Runnable**（如 LCEL chain） | 框架在 invoke 前后调 `get_history(session_id)`，取/写消息 | P4_RAG 的 `rag.py`：chain 外包一层 `RunnableWithMessageHistory`，传入 `get_history`，config 里用 `session_id` |
| **create_agent + checkpointer + thread_id** | **CompiledStateGraph**（create_agent 返回的图） | **图内部**在每步做 checkpoint，不涉及 BaseChatMessageHistory | 创建 agent 时传 `checkpointer`，调用时传 `config={"configurable": {"thread_id": "xxx"}}`，每轮只传**本轮**用户消息 |

- P4_RAG 的 `file_history_store.py` 实现的是 **BaseChatMessageHistory**，是给 **RunnableWithMessageHistory** 用的；  
- 当前 yun_bot 的 agent 用的是 **create_agent**，返回的是**图**，不是被 RunnableWithMessageHistory 包装的 Runnable，所以**不会**去“调用”你的 FileChatMessageHistory。  
- 因此：**create_agent 的官方对话存储方式是用 checkpointer + thread_id，而不是 BaseChatMessageHistory。**

下面先说明 create_agent 的官方做法，再说明若仍想用“文件存储”时如何在图外自己维护历史（与 BaseChatMessageHistory 的关系）。

---

## 2. create_agent 官方的对话存储：checkpointer + thread_id

### 2.1 思路

- `create_agent` 支持参数 **`checkpointer`**，类型是 LangGraph 的 `Checkpointer`。
- 调用 **`stream` / `invoke`** 时传入 **`config={"configurable": {"thread_id": "某个会话 id"}}`**。
- 图在执行时会：
  - 根据 `thread_id` **自动恢复**该线程的上一次 state（包含 `messages`）；
  - 把你本次传入的 **`inputs["messages"]`**（通常只包含**本轮**的一条用户消息）**追加**到该 state；
  - 执行完后在**每一步**把新 state **写回** checkpointer。

因此：**你不需要**在业务里手动“加载历史消息、拼好再传进去、流式完再写回”。只要每轮传本轮的 user message，并保持同一 `thread_id`，多轮对话就由图 + checkpointer 自动完成。

### 2.2 代码用法示例

```python
from langchain.agents import create_agent
from langgraph.checkpoint.memory import MemorySaver  # 开发用内存；生产可用 SqliteSaver / PostgresSaver 等

# 创建带持久化的 agent
checkpointer = MemorySaver()
agent = create_agent(
    model=...,
    tools=[...],
    system_prompt=...,
    checkpointer=checkpointer,  # 关键：交给图内部做 state 持久化
)

# 每轮只传本轮用户消息；用 thread_id 区分会话
session_id = "user_123"  # 或 QQ user_id
config = {"configurable": {"thread_id": session_id}}

for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "今天天气怎么样？"}]},
    config=config,
    stream_mode="values",
):
    ...

# 下一轮同一 session_id，图会自动带上上一轮及之前的 messages
for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "那明天呢？"}]},
    config=config,
    stream_mode="values",
):
    ...
```

### 2.3 checkpointer 实现选型

- **开发 / 单进程**：`langgraph.checkpoint.memory.MemorySaver()`，仅内存，进程重启即丢。
- **持久化、本地**：`langgraph-checkpoint-sqlite` 的 `SqliteSaver`，按 `thread_id` 存 SQLite。
- **生产 / 多进程**：`langgraph-checkpoint-postgres` 的 `PostgresSaver` 等。

安装示例：

```bash
# SQLite 持久化
pip install langgraph-checkpoint-sqlite
```

```python
from langgraph.checkpoint.sqlite import SqliteSaver

with SqliteSaver.from_conn_string("./data/agent_checkpoints.db") as checkpointer:
    agent = create_agent(..., checkpointer=checkpointer)
    # 调用时同样用 config={"configurable": {"thread_id": session_id}}
```

总结：**create_agent 做对话存储，正确做法是用 checkpointer + 调用时传 thread_id，而不是用 BaseChatMessageHistory。**

---

## 3. 和 P4_RAG 的 BaseChatMessageHistory 的关系

- **P4_RAG**：  
  - 用的是 **Runnable**（chain），用 **RunnableWithMessageHistory** 包装，并传入 **get_history**（返回 `BaseChatMessageHistory`）。  
  - 框架在 invoke 时根据 config 里的 **session_id** 调 `get_history(session_id)` 取/写消息。  
  - 因此那里的 **FileChatMessageHistory** 是“被 RunnableWithMessageHistory 调用”的，和 create_agent 无关。

- **create_agent**：  
  - 返回的是 **图**，图内部只认 **checkpointer** 和 **thread_id**，**不会**去调 BaseChatMessageHistory。  
  - 若你希望“和 P4_RAG 一样用文件存消息”（例如 JSON 文件、不要 SQLite/Postgres），可以在 **图的外层** 自己：  
    - 用类似 `FileChatMessageHistory` 的东西按 session_id 读/写消息；  
    - 每次调用前从文件加载历史 messages，拼上本轮用户消息，作为 `inputs["messages"]` 传给 `agent.stream(..., config=...)`；  
    - 流式结束后再把图返回的整段 `messages` 写回文件。  
  - 这种做法是**自己在图外做了一层“对话存储”**，**不是** create_agent 提供的机制；图本身仍然可以不用 checkpointer（即无图内持久化），只是你多了一个“按文件维护的 messages”而已。

若采用“图外 + 文件”方案，之前文档里提到的 `file_history_store.py`（或类似实现）仍然可以用于“按 session_id 存一份消息列表”；只是要明确：**它不是被 create_agent 调用的，而是被你在 ReactAgent.execute_stream 等业务逻辑里手动调用的。**

---

## 4. 小结

| 需求 | 推荐做法 |
|------|----------|
| 使用 **create_agent** 且要做多轮对话 | 使用 **checkpointer + thread_id**：`create_agent(..., checkpointer=...)`，调用时 `config={"configurable": {"thread_id": session_id}}`，每轮只传本轮 user message。 |
| 使用 **Runnable（chain）** 且要做多轮对话 | 使用 **RunnableWithMessageHistory + BaseChatMessageHistory**（如 P4_RAG 的 `get_history` + `FileChatMessageHistory`），config 里用 `session_id`。 |
| 坚持用 **文件（如 JSON）** 存消息、且 agent 是 create_agent | 要么：用 **SqliteSaver** 等把 checkpointer 落到本地文件/DB；要么：在 **图外** 用 FileChatMessageHistory（或类似）手动 load/save messages，并明确这不是 create_agent 内置能力。 |

**create_agent 的对话存储，应优先采用 LangGraph 的 checkpointer + thread_id 方式；BaseChatMessageHistory 是给 RunnableWithMessageHistory 用的，不直接用于 create_agent。**
