# Agent 会话记忆存储说明

本文说明 **LangChain `create_agent` 的对话存储机制**，以及它与 P4_RAG 里「Runnable + BaseChatMessageHistory」方式的区别，便于在 yun_bot 的 agent_app 中正确做多轮会话记忆。

---

## 1. 两套不同的“对话存储”机制

LangChain 里和“多轮对话、会话记忆”相关的常见有两种，**不要混用**：

| 机制 | 适用对象 | 谁在“调”存储 | 典型用法 |
|------|----------|----------------|----------|
| **RunnableWithMessageHistory + BaseChatMessageHistory** | 普通 **Runnable**（如 LCEL chain） | 框架在 invoke 前后调 `get_history(session_id)`，取/写消息 | P4_RAG 的 `rag.py`：chain 外包一层 `RunnableWithMessageHistory`，传入 `get_history`，config 里用 `session_id` |
| **create_agent + checkpointer + thread_id** | **CompiledStateGraph**（create_agent 返回的图） | **图内部**在每步做 checkpoint，不涉及 BaseChatMessageHistory | 创建 agent 时传 `checkpointer`，调用时传 `config={"configurable": {"thread_id": "xxx"}}`，每轮只传**本轮**用户消息 |

- P4_RAG 的 `file_history_store.py` 实现的是 **BaseChatMessageHistory**，是给 **RunnableWithMessageHistory** 用的；  
- 当前 yun_bot 的 agent 用的是 **create_agent**，返回的是**图**，不是被 RunnableWithMessageHistory 包装的 Runnable，所以**不会**去“调用”你的 FileChatMessageHistory。  
- 因此：**create_agent 的官方对话存储方式是用 checkpointer + thread_id，而不是 BaseChatMessageHistory。**

下面先说明 create_agent 的官方做法，再说明若仍想用“文件存储”时如何在图外自己维护历史（与 BaseChatMessageHistory 的关系）。

---

## 2. create_agent 官方的对话存储：checkpointer + thread_id

### 2.1 思路

- `create_agent` 支持参数 **`checkpointer`**，类型是 LangGraph 的 `Checkpointer`。
- 调用 **`stream` / `invoke`** 时传入 **`config={"configurable": {"thread_id": "某个会话 id"}}`**。
- 图在执行时会：
  - 根据 `thread_id` **自动恢复**该线程的上一次 state（包含 `messages`）；
  - 把你本次传入的 **`inputs["messages"]`**（通常只包含**本轮**的一条用户消息）**追加**到该 state；
  - 执行完后在**每一步**把新 state **写回** checkpointer。

因此：**你不需要**在业务里手动“加载历史消息、拼好再传进去、流式完再写回”。只要每轮传本轮的 user message，并保持同一 `thread_id`，多轮对话就由图 + checkpointer 自动完成。

### 2.2 代码用法示例

```python
from langchain.agents import create_agent
from langgraph.checkpoint.memory import MemorySaver  # 开发用内存；生产可用 SqliteSaver / PostgresSaver 等

# 创建带持久化的 agent
checkpointer = MemorySaver()
agent = create_agent(
    model=...,
    tools=[...],
    system_prompt=...,
    checkpointer=checkpointer,  # 关键：交给图内部做 state 持久化
)

# 每轮只传本轮用户消息；用 thread_id 区分会话
session_id = "user_123"  # 或 QQ user_id
config = {"configurable": {"thread_id": session_id}}

for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "今天天气怎么样？"}]},
    config=config,
    stream_mode="values",
):
    ...

# 下一轮同一 session_id，图会自动带上上一轮及之前的 messages
for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "那明天呢？"}]},
    config=config,
    stream_mode="values",
):
    ...
```

### 2.3 用图就一定要上数据库吗？能用 JSON 吗？

**不必上“数据库”。**

- **不需要独立数据库服务**：  
  - `MemorySaver`：只占内存，不落盘，进程重启就丢，适合开发。  
  - `SqliteSaver`：落盘的是一个 **SQLite 单文件**（如 `./data/agent_checkpoints.db`），**没有** PostgreSQL/MySQL 那种独立 DB 服务，装好 `langgraph-checkpoint-sqlite` 就能用，通常算“用文件存”而不是“上数据库”。

- **若坚持用 JSON 文件存**：  
  LangGraph 官方没有提供“按 JSON 文件”的 checkpointer（只有 Memory / SQLite / Postgres / MongoDB 等）。所以有两种做法：  
  1. **仍用图，但不用 checkpointer**：图只负责推理；持久化用你自己那套 **JSON（如 FileChatMessageHistory）**：每轮前 load → 拼好 `messages` 传给 `agent.stream(inputs)`，流式结束后再把图返回的 messages 写回 JSON。也就是「图 + 全程自己用 JSON 拼接」，图照样用，只是存不交给 checkpointer。  
  2. **用图 + checkpointer**：选 `SqliteSaver`，存的是一个 `.db` 文件，格式不是 JSON 但也是单文件、无需起数据库服务。

**结论**：用图不强制引入“数据库”；要 JSON 存就用「图 + 自己用 JSON 做对话存储」；要官方持久化又不想起 DB 服务就用 SqliteSaver 单文件。

### 2.4 checkpointer 实现选型（当你决定用 checkpointer 时）

- **开发 / 单进程**：`langgraph.checkpoint.memory.MemorySaver()`，仅内存，进程重启即丢。
- **持久化、本地单文件**：`langgraph-checkpoint-sqlite` 的 `SqliteSaver`，一个 `.db` 文件，无需独立 DB 服务。
- **生产 / 多进程**：`langgraph-checkpoint-postgres` 的 `PostgresSaver` 等。

安装示例：

```bash
# SQLite 持久化
pip install langgraph-checkpoint-sqlite
```

```python
from langgraph.checkpoint.sqlite import SqliteSaver

with SqliteSaver.from_conn_string("./data/agent_checkpoints.db") as checkpointer:
    agent = create_agent(..., checkpointer=checkpointer)
    # 调用时同样用 config={"configurable": {"thread_id": session_id}}
```

总结：**create_agent 做对话存储，正确做法是用 checkpointer + 调用时传 thread_id，而不是用 BaseChatMessageHistory。**

### 2.5 记忆会无限制增长吗？有没有自动总结？

**不会由 create_agent 封装好，默认会无限制记忆。**

- **checkpointer 只做一件事**：按 `thread_id` 把图的 **完整 state**（包括整条 `messages` 列表）在每一步保存/恢复，不做截断、不做总结、也不限制条数。
- 因此：对话轮数一多，**state 里的 messages 会一直追加**，既占存储，也可能在调用模型时超出上下文长度。**“记多少”“何时总结”都不是 create_agent 自带的**，需要自己在业务或图里做。

常见做法（需自行实现，而非 create_agent 内置）：

| 需求 | 做法 |
|------|------|
| 只保留最近 N 条消息 | 在 state 的 **reducer** 里对 `messages` 做截断（如只保留最后 N 条），或调用前用 LangChain 的 **`trim_messages()`** 按条数/ token 截断再传给模型。 |
| 控制发给模型的上下文长度 | 在调用 LLM 的节点里，对 `state["messages"]` 先 **trim_messages**（按 token 或条数），再 `model.invoke(trimmed)`，这样存的是全量，但模型只看到最近一段。 |
| 对旧对话做总结再继续 | 自己写逻辑：当消息超过一定条数/长度时，用模型把旧消息总结成一条 system 或 user 消息，替换掉旧消息后再继续，然后再 checkpoint。 |

结论：**用官方 checkpointer 只是“有持久化、能多轮”，记忆上限和总结策略都要自己设计实现。**

---

## 3. 和 P4_RAG 的 BaseChatMessageHistory 的关系

- **P4_RAG**：  
  - 用的是 **Runnable**（chain），用 **RunnableWithMessageHistory** 包装，并传入 **get_history**（返回 `BaseChatMessageHistory`）。  
  - 框架在 invoke 时根据 config 里的 **session_id** 调 `get_history(session_id)` 取/写消息。  
  - 因此那里的 **FileChatMessageHistory** 是“被 RunnableWithMessageHistory 调用”的，和 create_agent 无关。

- **create_agent**：  
  - 返回的是 **图**，图内部只认 **checkpointer** 和 **thread_id**，**不会**去调 BaseChatMessageHistory。  
  - 若你希望“和 P4_RAG 一样用文件存消息”（例如 JSON 文件、不要 SQLite/Postgres），可以在 **图的外层** 自己：  
    - 用类似 `FileChatMessageHistory` 的东西按 session_id 读/写消息；  
    - 每次调用前从文件加载历史 messages，拼上本轮用户消息，作为 `inputs["messages"]` 传给 `agent.stream(..., config=...)`；  
    - 流式结束后再把图返回的整段 `messages` 写回文件。  
  - 这种做法是**自己在图外做了一层“对话存储”**，**不是** create_agent 提供的机制；图本身仍然可以不用 checkpointer（即无图内持久化），只是你多了一个“按文件维护的 messages”而已。

若采用“图外 + 文件”方案，之前文档里提到的 `file_history_store.py`（或类似实现）仍然可以用于“按 session_id 存一份消息列表”；只是要明确：**它不是被 create_agent 调用的，而是被你在 ReactAgent.execute_stream 等业务逻辑里手动调用的。**

---

## 4. 小结

| 需求 | 推荐做法 |
|------|----------|
| 使用 **create_agent** 且要做多轮对话 | 使用 **checkpointer + thread_id**：`create_agent(..., checkpointer=...)`，调用时 `config={"configurable": {"thread_id": session_id}}`，每轮只传本轮 user message。 |
| 使用 **Runnable（chain）** 且要做多轮对话 | 使用 **RunnableWithMessageHistory + BaseChatMessageHistory**（如 P4_RAG 的 `get_history` + `FileChatMessageHistory`），config 里用 `session_id`。 |
| 坚持用 **文件（如 JSON）** 存消息、且 agent 是 create_agent | 要么：用 **SqliteSaver** 等把 checkpointer 落到本地文件/DB；要么：在 **图外** 用 FileChatMessageHistory（或类似）手动 load/save messages，并明确这不是 create_agent 内置能力。 |

**create_agent 的对话存储，应优先采用 LangGraph 的 checkpointer + thread_id 方式；BaseChatMessageHistory 是给 RunnableWithMessageHistory 用的，不直接用于 create_agent。**  
**记忆条数、长度限制、旧对话总结等均非 create_agent 内置，需自行在 reducer / trim_messages / 总结逻辑中实现。**

---

## 5. 选型：checkpointer + 截断/总结 vs 全程自己拼接

两种都能做多轮 + 控制长度，区别在于「谁负责存、谁负责截断/总结」。

| 维度 | **checkpointer + 自己在图里做截断/总结** | **全程自己拼接（图外 FileChatMessageHistory 等）** |
|------|------------------------------------------|-----------------------------------------------------|
| **谁存** | 图 + checkpointer（Sqlite / Postgres 等） | 你自己（JSON 文件 / 任意存储） |
| **谁截断/总结** | 你在图的 reducer 或调用 LLM 前（trim_messages / 总结逻辑） | 你在业务层 load 后先 trim 或总结，再拼成 `messages` 传给图 |
| **优点** | 和图原生集成；多进程/多机可共用同一 DB；官方文档、生态多 | 逻辑全在一处（业务层），易控格式、易做总结；不依赖 LangGraph 存储 |
| **缺点** | 要动图/state（reducer 或节点内 trim），总结逻辑也要接在图里 | 要自己保证「流式跑完再 save」等约定；和图解耦，升级 create_agent 时存储层自己维护 |

**建议怎么选：**

- **想少操心存储、愿意用 SQLite/Postgres，且接受在图里加一点截断逻辑**  
  → 用 **checkpointer + 截断**（先只做 trim_messages 按条数/ token 截断，总结可以后面再加）。这样「存」交给官方，「记多少」自己控制，一条路走到底。

- **想存储完全可控、希望用 JSON 文件或现有存储，或希望截断/总结全部在业务层一目了然**  
  → 用 **全程自己拼接**：业务层 `get_history(session_id)` → 读消息 → 按需截断/总结 → 拼上本轮 user message → `agent.stream(inputs)`（不传 config 或不用 checkpointer）→ 流式结束后把图返回的 messages 再写回。create_agent 只负责“算”，不负责“记”。

- **不打算做总结、只做简单“最近 N 条”**  
  → 两种都行：checkpointer + 在调用模型前 trim_messages；或自己拼接时只保留最后 N 条再传给图。选你更顺手的那条路即可。

**一句话**：要「和图深度集成、用官方持久化」就选 **checkpointer + 截断（+ 可选总结）**；要「存储和长度逻辑全在自己手里、好排查」就选 **全程自己拼接**。不必两个一起上，二选一即可。
